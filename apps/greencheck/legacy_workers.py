import phpserialize
from dataclasses import dataclass
from django.utils import dateparse

import logging
console = logging.StreamHandler()
logger = logging.getLogger(__name__)
# logger.setLevel(logging.INFO)
# logger.addHandler(console)

@dataclass
class SiteCheck:
    """
    A representation of the Sitecheck object from the PHP app.
    We use it as a basis for logging to the Greencheck, but also maintaining
    our green_domains tables.
    """

    url: str
    ip: str
    data: bool
    hosting_provider_id: int
    checked_at: str
    match_type: str
    match_ip_range: int
    cached: bool
    checked_at: str




class LegacySiteCheckLogger:
    """
    A worker to consume messages from RabbiqMQ, generated by the enqueue library
    in the TGWF greencheck-api php app.

    Takes a PHP serialised data, and writes the necessary values to the greencheck
    logger tables.
    """
    php_dict = None

    def parse_serialised_php(self, body: bytes = None):
        """
        Accept a bytes string of encoded PHP, parses it returning
        a datastructure we can more easily parse
        """

        parsed_php = phpserialize.loads(body, object_hook=phpserialize.phpobject)
        result = parsed_php.get(b'result')
        self.php_dict = result._asdict()

        return self.php_dict


    def sitecheck_from_php_dict(self, body: bytes = None):
        """
        Accept a dict from parsed php, and return a datastructure without the name
        spacing.
        """
        php_dict = self.parse_serialised_php(body)

        return SiteCheck(
            ip=self.prefixed_attr("ip"),
            url=self.prefixed_attr("checkedUrl"),
            data=self.prefixed_attr("data"),
            cached=self.prefixed_attr("cached"),
            hosting_provider_id=self.prefixed_attr("idHostingProvider"),
            match_type=self.prefixed_attr("matchtype").get("type"),
            match_ip_range=self.prefixed_attr("matchtype").get("id"),
            checked_at=self.prefixed_attr("checkedAt"),
        )


    def prefixed_attr(self, key):
        """
        Returns the value, as an appropriate type based what we
        find matching `key` in our phpdict:
        """

        # we have no dict parsed yet, return early
        if self.php_dict is None:
            return None

        prefix = "\x00TGWF\\Greencheck\\SitecheckResult\x00"
        full_length_key = f"{prefix}{key}"

        # we need to use bytes rather than a string for our key
        res = self.php_dict.get(full_length_key.encode())

        logger.debug(key)

        if key == "checkedAt":
            return self.get_checked_at(res)

        if key == "matchtype":
            return self.get_match_type(res)


        return self.cast_from_php(res)


    def cast_from_php(self, res):
        """
        Accept a value, and based on the type, return the tidier representation
        """
        if isinstance(res, bytes):
            return res.decode("utf-8")

        if isinstance(res, bool):
            return res

        if isinstance(res, int):
            return res

        if isinstance(res, dict):
            cleaned_res = {}
            for key, val in res.items():
                cleaned_res[key.decode('utf-8')] = self.cast_from_php(val)
            if "ipv4" or "ipv6" in cleaned_res.keys():
                # return just the ip address
                single_ip, *_ = [v for k, v in cleaned_res.items() if v]
                return single_ip

    def get_match_type(self, res=None):
        """
        Return the match type passed in. Because we can't be sure
        that the checked IP range still exists, we need to extract it
        now, rather than re-fetching it when adding it to the greencheck
        table.
        """
        cleaned_res = {}
        for key, val in res.items():
            cleaned_res[key.decode('utf-8')] = self.cast_from_php(val)

        return cleaned_res


    def get_checked_at(self, res):
        """
        Return the date of the check. Because the date is
        a dict, we need to fetch only the value we need.
        """
        # coerce the <phpobject b'DateTime'> to a dict
        date_dict = res._asdict()
        cleaned_res = {}

        for key, val in res._asdict().items():
            cleaned_res[key.decode('utf-8')] = self.cast_from_php(val)

        parsed_datetime = dateparse.parse_datetime(cleaned_res.get("date"))
        formatted_date = parsed_datetime.strftime("%Y-%m-%d %H:%M:%S")

        return formatted_date

